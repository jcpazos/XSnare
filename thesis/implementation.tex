\section{Implementation} \label{implementation}

We implemented our system as an extension in Firefox 69.0. Our signatures are stored in a local JavaScript file in the extension package. We decided on an extension implementation for several reasons.
% (1) \emph{Ease of deployment and adoption}. Modern browsers provide a convenient way to upload extensions to their respective official sites (Firefox Add-Ons in the case of Firefox). %% This eases deployment for the extension developer, and users can install the tool within the browser in one click, without any additional third-party software. Previous client-side work often applies browser modifications. Most users might not be willing to adopt new browsers, since it might affect usability for them.
(1) \emph{Privileged execution environment}. The extension's logic lies in a separate environment from the web application code. This guarantees that malicious code in the application cannot affect the extension. %% If the extension needs to run code within the application, it can maintain security by installing the code before the application's code runs.
(2) \emph{Web application context}. Our solution requires knowledge of the application's context. %% For example, it's useful to know which tab generated a network request to determine whether the response content is safe or not. 
The extension naturally retains this context.
(3) \emph{Interposition abilities}. As it lies within the browser, the extension can run both at the network level, e.g., rewrite an incoming response; and at the web application level, e.g., interpose on the application's JavaScript execution. % Other types of solutions often have to choose between one or the other.

%% \begin{itemize}
%% 	\item \textbf{Ease of deployment and adoption}. Most modern browsers provide a convenient way to upload extensions to their respective official sites (Firefox Add-Ons in the case of Firefox). This eases deployment for the extension developer, and users can install the tool within the browser in one click, without any additional third-party software. Previous client-side work often applies browser modifications. Most users might not be willing to adopt new browsers, since it might affect usability for them.
%% 	\item \textbf{Privileged execution environment}. The extension's logic lies in a separate environment from the web application code. This is important for security, as it guarantees that any malicious code in the application can not affect the extension's behaviour. If the extension needs to run code within the application, it can maintain security by installing the code before the application's code runs.
%% 	\item \textbf{Web application context}. Our solution requires knowledge of the application's context to perform several of its tasks. For example, it's useful to know which tab generated a network request to determine whether the response content is safe or not. The extension naturally retains this context.
%% 	\item \textbf{Ability to interpose at the network level and the web application level}. As it lies within the browser, the extension can run both at the network level, e.g., rewrite an incoming response or outgoing request; and at the web application level, e.g., keeping track of click events, or interpose on the application's JavaScript execution. Other types of solutions often have to choose between one or the other.
%% \end{itemize}
\begin{algorithm}[tb]
	\SetAlgoLined
	//global DBSignatures\\
	\SetKwProg{verifyResponse}{procedure \emph{verifyResponse}}{}{end}
	\verifyResponse{(responseString, url)}{
	 loadedProbes = runProbes(responseString, url)\\
	 signaturesToCheck $\leftarrow$ []\\
	 \For{probe in loadedProbes}{
	 	signaturesToCheck.append(DBSignatures[probe])\
 	 }
  	 filteredSignatures $\leftarrow$ []\\
  	 \For{signature in signaturesToCheck} {
  	 	\uIf{responseString and url match signature}{
  	 		filteredSignatures.push(signature)\\
  	 	}
  	 }
     versionInfo $\leftarrow$ loadVersions(url, loadedProbes)\\
     endPoints $\leftarrow$ [] \\
     \For{signature in filteredSignatures} {
     	\uIf{(signature,signature.version) $\in$ versionInfo}{
     		endPoints.push(signature.endPointPairs)\\
     	}
    }
	indices $\leftarrow$ [] \\ 
	\For{endPointPair in endPoints} {
		indices.push(findIndices(responseString, endPointPair))\\
	}
	\uIf{discrepancies exist in indices}{
       	Block page load and return\\
	}
	\For{endPointPair in endPoints} {
		sanitize(responseString,indices)\\
	}
		\caption{Network filter algorithm}
		\label{filter_algorithm}
	}
\end{algorithm}

\subsection{Filtering process} \label{filtering_process}
\autoref{filter_algorithm} describes our network filtering process: once a request's response comes in through the network, we process it and sanitize it if necessary.

\textbf{Loading signatures.}
Our detector loads signatures and finds injection points in the document. However, not all signatures need to be loaded for a specific website, since not all sites run the same frameworks. When loading signatures, we proceed in a manner similar to a decision tree. The detector first probes the page (line 3) to identify the underlying framework (the \textbf{software} in our signature language). We currently provide a number of static probes. However, as more applications are required to be included, we believe it would be better to cover this task in the signature definitions. The widely popular network mapping tool Nmap~\cite{nMap} uses probes in a similar manner, kept in a modifiable file. As mentioned in \autoref{viability}, we currently only have signatures for \acp{CMS} applications. Our probes use specific identifiers related to the application, as well as the particular site that is affected by the exploit. WordPress pages, for example, have several elements in the page that identify it as a WordPress page. While this might seem easier for CMS style pages, and we acknowledge that application fingerprinting is a hard problem in general, we believe other web apps will also have similar identifying information, like headers, element ID's, script/CSS sources, classes, etc. Previous work has shown that DOM element boundaries can be effectively identified given some previous knowledge of the DOM structure \cite{10.1145/1595696.1595711}.

After running these probes, the detector loads corresponding frameworks' signatures and filters out checks whether the information of each loaded signature matches the page (lines 5-12).

\textbf{Version identification.} We then apply version identification
(lines 13-16). Our objective for versioning is to prevent signatures from
triggering false positives on websites running patched software. We
found this to be one of the harder aspects of signature loading. In
many \acp{CMS}, for example, file names are not updated with the
latest version, and versioning information is often unavailable on the client-side.
%% This information is often more available to admins of a
%% site. While this might not be the bulk of users, it is the bulk of
%% disclosed CVEs, as described in \autoref{viability}.

We have observed that even if we load a signature when the
application has already been patched on the server, it can
preserve the page's functionality. Motivated by this observation, our mechanism
follows a series of increasingly accurate but less precise version
identifiers.
%: first, we apply framework specific version probes. If
%these are not successful, the signature language provides
%functionality for version identification in the HTML through regex. 
If versioning is unavailable in the HTML, the patch is applied
as we cannot be sure the page is running patched
software. %% Our tool takes advantage of having perfect knowledge of an
%% exploit's conditions, which reduces the rate of false positives
%% compared to a software-agnostic approach.

\textbf{Injection point search and sanitization.}
Once we have the correct signatures, we find the indices for the endpoints using our top-down, bottom-up scan, and need to check for potential malformations in the injection points (lines 19-24), as described in \autoref{multiple_injections}. If this occurs, the page load is blocked and a message is returned to the user, or if the signature developer specifies so, sanitization proceeds on the new endpoints. Finally, if all \textbf{endPoint} pairs are in the expected order, we sanitize each injection point (lines 25-27).

\subsection{Sanitization methods} \label{sanitization_methods}
We provide different types of sanitization: "DOMPurify", "escape", and "regex". DOMPurify works well as an out-of-the-box solution. Escaping can be useful when only a few characters need to be filtered. Regex Pattern matching can be particularly effective when the expected value has a simple representation (e.g., a field for only numbers). 
