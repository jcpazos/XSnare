\section{Implementation} \label{implementation}

We have implemented our browser extension in Firefox 69.0. Our signatures are currently stored in a local JavaScript file in the extension package. We have decided to implement this tool as an extension for four reasons:
(1) \textbf{Ease of deployment and adoption} Most modern browsers provide a convenient way to upload extensions to their respective official sites (Firefox Add-Ons in the case of Firefox). %% This eases deployment for the extension developer, and users can install the tool within the browser in one click, without any additional third-party software. Previous client-side work often applies browser modifications. Most users might not be willing to adopt new browsers, since it might affect usability for them.
(2) \textbf{Privileged execution environment}. The extension's logic lies in a separate environment from the web application code. This is important for security, as it guarantees that any malicious code in the application cannot affect the extension's behavior. %% If the extension needs to run code within the application, it can maintain security by installing the code before the application's code runs.
(3) \textbf{Web application context}. Our solution requires knowledge of the application's context to perform several of its tasks. %% For example, it's useful to know which tab generated a network request to determine whether the response content is safe or not. 
The extension naturally retains this context.
(4) \textbf{Ability to interpose at the network level and the web application level}. As it lies within the browser, the extension can run both at the network level, e.g., rewrite an incoming response; and at the web application level, e.g., interpose on the application's JavaScript execution. % Other types of solutions often have to choose between one or the other.

%% \begin{itemize}
%% 	\item \textbf{Ease of deployment and adoption}. Most modern browsers provide a convenient way to upload extensions to their respective official sites (Firefox Add-Ons in the case of Firefox). This eases deployment for the extension developer, and users can install the tool within the browser in one click, without any additional third-party software. Previous client-side work often applies browser modifications. Most users might not be willing to adopt new browsers, since it might affect usability for them.
%% 	\item \textbf{Privileged execution environment}. The extension's logic lies in a separate environment from the web application code. This is important for security, as it guarantees that any malicious code in the application can not affect the extension's behaviour. If the extension needs to run code within the application, it can maintain security by installing the code before the application's code runs.
%% 	\item \textbf{Web application context}. Our solution requires knowledge of the application's context to perform several of its tasks. For example, it's useful to know which tab generated a network request to determine whether the response content is safe or not. The extension naturally retains this context.
%% 	\item \textbf{Ability to interpose at the network level and the web application level}. As it lies within the browser, the extension can run both at the network level, e.g., rewrite an incoming response or outgoing request; and at the web application level, e.g., keeping track of click events, or interpose on the application's JavaScript execution. Other types of solutions often have to choose between one or the other.
%% \end{itemize}

\begin{algorithm} 
	\SetAlgoLined
	//global DBSignatures\\
	\SetKwProg{verifyResponse}{procedure \emph{verifyResponse}}{}{end}
	\verifyResponse{(responseString, url)}{
	 loadedProbes = runProbes(responseString, url)\\
	 signaturesToCheck $\leftarrow$ []\\
	 \For{probe in loadedProbes}{
	 	signaturesToCheck.append(DBSignatures[probe])\
 	 }
  	 filteredSignatures $\leftarrow$ []\\
  	 \For{signature in signaturesToCheck} {
  	 	\uIf{responseString and url match signature}{
  	 		filteredSignatures.push(signature)\\
  	 	}
  	 }
     versionInfo $\leftarrow$ loadVersions(url, loadedProbes)\\
     endPoints $\leftarrow$ [] \\
     \For{signature in filteredSignatures} {
     	\uIf{(signature,signature.version) $\in$ versionInfo}{
     		endPoints.push(signature.endPointPairs)\\
     	}
    }
	indices $\leftarrow$ [] \\ 
	\For{endPointPair in endPoints} {
		indices.push(findIndices(responseString, endPointPair))\\
	}
	\uIf{discrepancies exist in indices}{
       	Block page load and return\\
	}
	\For{endPointPair in endPoints} {
		sanitize(responseString,indices)\\
	}
		\caption{Network filter algorithm}
		\label{filter_algorithm}
	}
\end{algorithm}

\subsection{Filtering process} \label{filtering_process}
Algorithm \ref{filter_algorithm} describes our network filtering process: once a request's response comes in through the network, we process it and sanitize it if necessary.

\subsubsection{Loading signatures} \label{loading_signatures}
Our detector loads signatures and finds injection points in the document. However, not all signatures need to be loaded for a specific website, since not all sites run the same frameworks. When loading signatures, we proceed in a manner similar to a decision tree. The detector first probes the page (line 3) to identify the underlying framework (the \textbf{software} in our signature language). We currently provide a number of static probes. However, as more applications are required to be included, we believe it would be better to cover this task in the signature definitions. The widely popular network mapping tool Nmap~\cite{nMap} uses probes in a similar manner, kept in a modifiable file. As mentioned in Section \ref{viability}, we currently only have signatures for CMS applications. Our probes use specific identifiers related to the application, as well as the particular site that is affected by the exploit. WordPress pages, for example, have several elements in the page that identify it as a WordPress page. While this might seem easier for CMS style pages, we believe other web apps will also have similar identifying information, like headers, element ID's, script/CSS sources, etc.

After running these probes, the detector loads corresponding frameworks' signatures and filters out checks whether the information of each loaded signature matches the page (lines 5-12).

\subsubsection{Version identification} \label{versioning}
We then apply version identification (lines 13-16). Our objective for versioning is that our signatures don't trigger false positives on websites running patched software. We found this to be one of the harder aspects of signature loading. In many \acp{CMS}, for example, file names are not updated with the latest versions, or do not include them at all, and thus, this information is often hard to come by from the client-side perspective. This information is often more available to admins of a site. While this might not be the bulk of users, it is the bulk of disclosed CVEs, as described in Section \ref{viability}.

Furthermore, we believe that even if we load a signature when the application has already been fixed at the server-side, it will often preserve the page's functionality, as many of the CVEs are a result of unsanitized input. Motivated by this observed behavior, our mechanism follows a series of increasingly accurate but less applicable version identifiers: first, we apply framework specific version probes. If these are not successful, the signature language provides functionality for version identification in the HTML through regex. If information is unavailable through the HTML, the version in the signature is left blank and the patch is applied regardless of version, as we can not be sure the page is running patched software. Our tool takes advantage of having perfect knowledge of an exploit's conditions, which reduces the rate of false positives compared to a software-agnostic approach.

\subsubsection{Injection point search and sanitization} \label{search_and_sanitization}
Once we have the correct signatures, we find the indices for the endpoints using our top-down, bottom-up scan, and need to check for potential malformations in the injection points, as described in Section \ref{multiple_injections} (lines 19-24). The page load is blocked and a message is returned to the user, or if the signature developer specifies so, sanitization proceeds on the new endpoints. Finally, if all \textbf{endPoint} pairs are in the expected order, we sanitize each injection point (lines 25-27).

\subsection{Sanitization methods}
We provide different types of sanitization: "DOMPurify", "escape", and "regex". Regex Pattern matching can be particularly effective when the expected value has a simple representation (e.g., a field for only numbers). For each of these approaches, the signature can specify a corresponding config value. DOMPurify provides a rich API for additional configuration. When escaping, defining specific characters to escape via regex can be useful. For pattern matching via regex, config specifies the value the injected should match.
