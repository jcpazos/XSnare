Dear authors,

The The 23rd International Symposium on Research in Attacks, Intrusions and
Defenses (RAID 2020) program committee is sorry to inform you that your
submission #152 was rejected, and will not appear in the conference.

       Title: XSnare: Application-specific client-side cross-site scripting
              protection
     Authors: Jose Carlos Pazos (University of British Columbia)
              Jean-Sébastien Légaré (University of British Columbia)
              Ivan Beschastnikh (University of British Columbia)
        Site: https://raid20.usenix.hotcrp.com/paper/152

31 papers were accepted out of 121 submissions.

Visit the submission site for reviews, comments, and related information.
Reviews and comments are also included below.

Contact megele@bu.edu <megele@bu.edu> with any questions or concerns.

- RAID 2020 Submissions

Review #152A
===========================================================================

Overall merit
-------------
1. Reject

Reviewer expertise
------------------
3. Knowledgeable

Paper summary
-------------
This paper presents a client-side XSS detection system, implemented as a Firefox
extension and a signature database. The approach is a straightforward
application of static signature-based detection specifically crafted for
individual vulnerabilities and vulnerable applications. "Volunteers" are
expected to develop the signatures.

Comments for author
-------------------
-- Good

* The authors present an end-to-end system and demonstrate it's capabilities
  with real CVEs.

-- Bad

* The work is a straightforward implementation of signature-based
  detection. There is no new scientific knowledge.

* No structured presentation of the problem, solution, and limitations. The
  authors brush over limitations, and make misleading claims about the system's
  practical value. This paper needs a significant overhaul of its writing.

-- Comments

* Please see the negatives above re. lack of a scientific problem analysis
  framework or new knowledge, and lack of transparency about limitations. Some
  of these issues could have been easily mitigated with an earnest framing of
  the problem and the system's limitations: XSnare being "application specific"
  isn't any different from every other signature-based defense, that's the
  definition of a signature vs. heuristics or behavioral analyses. The approach
  can only be applied to certain types of applications due to practical
  signature development constraints. There are many advantages of generic
  XSS-filters over this system in other settings... the list goes on. I strongly
  recommend the authors to carefully state the problem, the research goals, and
  all the limitations. This is as opposed to assaulting the readers with
  defensive writing strategies. That'll immediately elevate the paper.

* On the presentation: The introduction is four sections in one: 1)
  introduction, 2) problem definition, 3) threat model, 4) sneak peek at related
  work (read: defensive writing so that reviewers don't attack the novelty
  aspect). The problem is, all four are interwoven, tightly coupling every
  single research motivation with a barrage of arbitrary examples bashing prior
  work. We finally understand what the proposed work is three pages in, and jump
  right into the design with no clear problem statement. Please separate each of these concerns into
  their own sections. Ditto above for the rest of the paper, please refactor.

* On the approach:

  - Let's first scope the problem. This work relies on 1) public vulnerability
    details, 2) humans to write signatures, 3) signatures to be distributed to
    multiple parties. These imply that XSnare primarily targets CMSs. That's
    because, per MITRE/CNA assignment rules, CVEs are only available when users
    have the capability to deploy patches on their own. That leaves out
    proprietary web application code.

  - "XSnare does not automatically determine the relevant actions to implement
   from a patch. We assign this task to a security analyst, who will act as the
   signature developer for a given exploit." XSnare is "someone else writing
   ~patches faster for your vulnerable application." That has to be called out
   early on, XSnare is just addressing the deployment problem. The scope is
   reusable components, where the upstream may patch, but users fail to
   adopt. This proposal rides on the assumption that signature development pace
   is quicker than upstream patching + world deployment.

  - The two points above shape the basic premise, yet these are left for the
   reader to infer from the design and cited works spread in between that discuss
   how CVEs are not getting patched in a timely manner. There is no problem
   statement or threat model.

  - "Previous client-side solutions have opted for detectors that were generic
   and site agnostic" XSnare's application-specific approach is pitched as the
   novelty. I would appreciate seeing an argument on why "a signature for every
   specific attack" isn't a step backwards. Section 3.1: XSnare is exposed to
   many problems of signatures, including the scalability issues. The authors
   obviously have a different view, and that's fine, but these should be
   discussed.

  - The frequent use of "DOM context" is misleading, as that implies a
   contextual analysis of the page (and there is no threat model or a formal
   description of what XSnare does to dispel that notion). Signatures are as
   static as they get, matching predefined injection points.

 - Please summarize what the sanitization involves -- that requires reading
   [25]. I'm not convinced this is all that different from the generic XSS
   filters that the authors claim don't work well. The only application-specific
   part here seems to be the added definition of an injection point. Yes, that
   may decrease false positives, and that's good. But otherwise, the
   sanitization rules themselves are quite generic, as attack payloads utilize
   flavors of generic techniques.

 - "We leave the design of an update mechanism to future work" This strongly
   clashes with the fact that XSnare signatures must outpace patch
   deployment. The lack of an update channel may be a simple engineering
   challenge for most work, but it's paramount to your argument that you at
   least have a game plan, if not a thoroughly evaluated implementation. In
   fact, that's the more interesting research question. I'd read a paper that
   solves the distribution issue, and leaves the signature engine for future
   work.

* "We initially considered other designs but quickly found out that applying the
  patch at the network level was necessary" Is that why you developed your
  extension for Firefox, and not Chrome? To the best of my knowledge Chrome
  extensions still can't access HTTP responses at the network level as a
  security design decision, but Firefox can. If that's the case, given that such
  access is crucial as per Section 2.4, it's an important limitation you need to
  discuss.

* The evaluation is quite detailed. I'm not going to comment on whether the
  overhead is acceptable as that's not pertinent to the scientific contributions
  of this paper. I do think working with more than 76 CVEs in a real-life
  deployment needs exploration. What happens with 1K, 10K signatures? It'd be
  very useful to have a view into the Figure 6 data in absolute terms; i.e.,
  end-to-end slow down with numbers. Even a five-number summary could work. "77%
  of cases less than a second" doesn't capture the essential information.

* Nitpicks:

    "Server-side defenses also do not protect against client-only forms of XSS"
    Development lifecycle and server-side networking defenses can very well
    prevent such attacks. You cited [34], but only the HTTP-hijacking attacker
    can bypass a server-side WAF there.

    Bibliography style inconsistent, check abbreviations, date formats, title
    capitalization... Where was [30] published at?

    "which impairs the usability of the sites [2, 33]". [33] almost argues
    against your message.

    Pedantic nit: it's input VALIDATION, and OUTPUT sanitization. I know input
    sanitization is a commonly (mis)used term, but that doesn't make it correct.


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Review #152B
===========================================================================

Overall merit
-------------
1. Reject

Reviewer expertise
------------------
4. Expert

Paper summary
-------------
XSnare is a system to prevent XSS. It allows developers to write rules that define injection points for XSS based on CVEs, and based on string matching can tell whether an attack happened or not. The system can still show a secured version of the site even if it is exploited.

Comments for author
-------------------
# Scope

Your coverage is very limited, extending the system to a handful of other CVEs shows that the system isn't limited to wordpress but if you consider how many CVEs are out, how many bugs never get reported etc. it becomes clear fast that making manual signatures is very limited in scope. Can you estimate how much work it would require you to write rules for *all* issued CVEs and what the performance impact on your engine would be? Manual signature generation is not scalable and does not stand up to the pace and security challenges of the web.

# System

String matching for injection points seems to be an idea that can be improved on. HTML is a programming language and searching for strings to start and stop is not an ideal approach. You have a tree that you can operate on where you blacklist points where JavaScript may not exist. You can do so only after a rule was manually written after a CVE has been issued. This is a long chain to lead to a successful attack prevention. If you were to apply a whitelist for where scripts *may* be injected and block all other injection points you might achieve a much higher success rate without all the manual effort.

On the zero day claim: "Our system can help defend against zero day attacks, as once a vulnerability is known, an analyst is able to write a signature for it as soon as they have knowledge of the issue." - A zero day attack is an attack for which there is no knowledge available. Your system requires prior knowledge of the attacks (write rules based on CVEs).

# Performance

"59 had consistent issues with timeouts, insecure certificates, and network errors" - this needs more explanation. If the extension breaks these websites that can't be ignored. Also the performance hit generally is very high.

Minor: This seems to apply only to certain URLs, if I add another parameter to the URL is it enough to evade detection? Matching of URLs isn't specified.

Minor: "a study of 76 CVEs in which we showed that it defends against 94.2%" - the percentage might be wrong, no integer fraction of 76 matches.


* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


Review #152C
===========================================================================

Overall merit
-------------
3. Weak accept

Reviewer expertise
------------------
3. Knowledgeable

Paper summary
-------------
In this paper the authors present XSnare, a client-side defense against XSS attacks. The main idea of the paper is that browsers can be extended with logic that can attempt to match whether a user is browsing a page that's vulnerable to XSS and whether that page currently includes maliciously-injected code. To do this, XSnare depends on a database of signatures that developers/enthusiasts manually develop that includes regular expressions to match vulnerabe paths (e.g. the path to a vulnerability in a WordPress plugin), the starting and ending point(s) within a page, as well as the type of data that should be there. In this way, if there's markup/JS that XSnare does not recognize, it can remove it or stop loading the page. The authors evaluate their solution with 76 CVEs (Mostly from WordPress plugins) and measure its performance overhead.

Comments for author
-------------------
This is a well-written paper that proposes work in a direction of defending against XSS where browsers are currently getting out of. Namely, most browsers are removing their XSS filters and essentially rely on CSP and websites explicitly denoting their script-inclusion preferences.

I applaud the authors for quantifying the applicability of XSnare against many different vulnerabilities, both in WordPress plugins as well as other CMSs. The proposed system, however, has the following issues:

- Signature generation and maintenance. The authors quantify how long it takes to create signatures (which is great) but see the process itself as out of scope for the paper. I understand the need to do this but this makes the proposed system highly unlikely to be ever adopted, unless a commercial solution does it. There is an incredible level of trust that's required here because allowing anyone and everyone to push signatures in a user's browser, can result in DoS attacks (at a minimum). What the authors effectively propose is the equivalent of an antivirus for the browser, with a list of signatures that come from a trustworthy entity. The developers of plugins/web applications will not do this (they already patched their code and released a new version) and neither will the websites that deploy these plugins and web applications (who might as well update their versions). Therefore this can only work if a commercial entity analyzes new CVEs and pushes signatures for them, !
 to the users with an active subscription of their product.

- Comparison with related work. The authors state that their work is different from past client-server papers (like BEEP and Noxes) because it does not require the help of the server. That's only possible because the authors assume that someone else will create these signatures that is not the server. Therefore, that someone else could also create BEEP policies that could be deployed to all out-of-the-box WordPress/Joomla/etc. web sites. Moreover, saying that old papers required changing the browser is not a fair comparison because of these papers were written before browsers were extendable via extensions (which is what the authors use).

- Applicability. XSnare is ideal when the injection converts something simple (like a non-HTML string or a number) to a malicious script (like the example in Section 2.1). There, it is clear that a regular expression can detect that what's present in the DOM is not a number and can stop the attack. When the original content is more complicated (like substantial amounts of HTML) then the signature has to be very precise and it's still unclear if that signature can be precise enough to stop an attack. The authors already encountered this since 12 of their signature "broke" the webpage on which they were active, therefore potentially penalizing users who use XSnare as well as websites that may very well have updated their plugins to their most recent versions.
