\section{Writing Signatures} \label{signature_writing}

We expect a signature developer to have a solid understanding of the principles behind \ac{XSS}, as well as web applications, HTML, CSS and JavaScript. In this section, we aim to show that minor effort is required from a knowledgeable analyst when writing a signature.


\subsection{Case Study: CVE-2018-10309} \label{case_study}
Going back to our example in Section \ref{motivating_example}, we describe the process by which a signature is written after a vulnerability has been discovered by using one of our studied CVEs.  

\textbf{Identifying the exploit.} An entry in Exploit Database \cite{studyCVE} describes a persistent \ac{XSS} vulnerability in the WordPress plugin Responsive Cookie Consent for versions 1.7/1.6/1.5. This particular entry (as most do) comes with a proof of concept (PoC) for the exploit: 
\begin{enumerate}
	\item Access WordPress control panel.
	\item Navigate to the Responsive Cookie Consent plugin page.
	\item Select one of the input fields. For example, "Cookie Bar Border Bottom Size".
	\item Insert the script you wish to inject.
	\item Save the plugin settings.
	\item Injected script will run in the victim's browser. Depending on which input field you inserted the script, the script may also run everytime you load the Responsive Cookie Consent plugin page.
	
\end{enumerate}

\textbf{Establishing the separation between dynamic and static content.} We insert the string \js{"$>$script$>$alert('XSS')$<$/script$>$} in the rcc\_settings[border-size] input field, as detailed by the PoC. This results in an alert box popping up in the page, which has the  following HTML:

\begin{lstlisting}
<input id="rcc_settings[border-size]" 
name="rcc-settings[border-size]" 
type="text" value=<@\textcolor{red}{""><script>alert('XSS')</script>}@>
<label class="description"
for="rcc_settings[border-size]">
\end{lstlisting}

In general, the CVE writer is able to find the vulnerable HTML from the server-side code without having to reproduce the exploit. Since we did not write the CVE, we had to do this extra step.

In this case, it is clear that the \textbf{input} element is the injection starting point, and we use the \textbf{label} element as the end point, since it is the element immediately after the \textbf{input}. We must emphasize that the identification of correct endpoints is extremely important. In particular, when multiple injection points exist in the same page, the signature developer must be cautious with the chosen elements, and ensure that these do not overlap with other innocuous ones. In some cases, the developer might find it best to completely stop the page from loading if they think the sanitization would affect the user experience too greatly. While one of our main goals is to maintain the page’s usability, there are cases where a large portion of the document would be affected by the sanitization, and we believe compromising usability for security is preferable in this case. Furthermore, the developer has to identify whether the exploit comes in from an external source (such as an Ajax request) or is embedded in the document’s mainframe HTML. 

\textbf{Collecting other required page information and writing the signature.} The next step is to gather the remaining information to determine whether the signature applies to the page loaded. The full signature for this example was previously shown in Listing \ref{lst:xsnare_signature}. The \textbf{URL} is acquired by noting that this exploit occurs on the plugin's settings page. The \textbf{software} running is WordPress in this case. The settings page's HTML includes a link to a stylesheet with href "http://localhost:8080/wp-content/plugins/responsive-cookie-consent/includes/css/options-page.css?ver=5.2.2", in particular, "wp-content/plugins/plugin-name" is the standard way of identifying that a WordPress page is running a certain plugin. In this case, "responsive-cookie-consent", set as \textbf{softwareDetails}. We apply the signature for all versions less than or equal to 1.7. Since, the exploit only occurs in this specific spot in the HTML, the \textbf{typeDet} is listed as 'single'. 
Since the vulnerable parameter is for border-size, the \textbf{sanitizer} applied is 'regex', further restricting the pattern to only numbers in \textbf{config}. Finally, we list the \textbf{endPoints} as taken from the HTML.

\textbf{Testing the signature}. Finally, we load up our extension and reload the web page. In this example, we expect to not have an alert box pop up, and we manually look at the HTML to verify correct sanitization. Note that there's nothing else in between the \textbf{input} and \textbf{label} elements now:

\begin{lstlisting}
<input value="" type="text" 
name="rcc_settings[border-size]" 
id="rcc_settings[border-size]">
<label class="description"
for="rcc_settings[border-size]">
\end{lstlisting}

In practice, there might be small discrepancies between server-side and client-side representations of the HTML string, leading to bugs in the signature if the developer used the parsed HTML as a reference. If the exploit is not properly sanitized, the developer is able to use the debugging tools provided by the browser to check the incoming network response information seen by the extension's background page and make sure it matches the signature values.

\iffalse
\subsection{Signature writing process}
We describe the process by which a signature is written after a vulnerability has been discovered:
\begin{enumerate}
	\item{
The signature developer crafts a proof of concept exploit for the given CVE. This step is not necessary but it will often help the developer correctly identify the affected areas of the DOM. For our own signatures, we heavily relied on this part because we often did not have the same information as the CVE writer.
Conversely, a knowledgeable analyst will often be able to identify the vulnerable points in the application from the server-side code.}
\item
Using information about where in the HTML the exploit will manifest itself, the developer identifies the start and end points of an injection, and creates regexes to match these. This step is particularly important because this is where the signature might end up covering a bigger part of the DOM than is required, potentially disabling desired functionality, to the detriment of the site user's experience. In particular, when multiple injection points occur in the same page, the developer might find it best to completely stop the page from loading if they think the sanitization would affect the user experience too greatly. While one of our main goals is to maintain the page's usability, there are cases where a large portion of the document would be affected by the sanitization, and we believe compromising usability for security is preferable in this case.

Furthermore, it is at this point where the developer identifies whether the exploit comes in from an external source (such as a response to an Ajax request or an external script) or is embedded in the document's mainframe HTML. This will result in a different signature layout. 
\item
Signatures are loaded for specific pages, and the developer has to specify this information, either via an URL or a regex in the HTML. For example, for a WordPress plugin, the exploit might happen in localhost/plugin-name.php. However, for another exploit, the exploit might occur in a page where the plugin is loaded, which contains the string "wp-content/plugins/plugin-name" in the HTML. Additionally, if the webpage is running pre-defined software, such as WordPress, this has to be specified in the signature as well. Much of this information is already known beforehand, and so this step can be done in conjunction with Step 2.
\item
After the signature has been written, the developer should make sure it was correctly specified. This is most easily done via testing a PoC exploit and verifying the injection has been properly sanitized. For false positives, the developer should make sure that the specified endPoints are uniquely occurring in the HTML (or if not unique, their correct positions have been stated). The browser extension can be used for the purposes of debugging. Some of our most common mistakes when writing signatures were incorrect regexes for the endpoints, and not correctly identifying that the injection occurred as part of an additional network request. These two can be easily fixed by looking through the incoming HTML in the background page's filter. 
\end{enumerate}

\subsection{Case Study: CVE-2018-10309}
Going back to our example in Section 2.4, we describe the full process of writing a signature for one of the CVEs we studied. An entry in Exploit Database \cite{studyCVE} describes a persistent \ac{XSS} vulnerability in the WordPress plugin Responsive Cookie Consent for versions 1.7/1.6/1.5. This particular entry (as most do) comes with a proof of concept for the exploit: 
\begin{enumerate}
\item Access WordPress control panel.
\item Navigate to the Responsive Cookie Consent plugin page.
\item Select one of the input fields. For example, "Cookie Bar Border Bottom Size".
\item Insert the script you wish to inject.
\item Save the plugin settings.
\item Injected script will run in the victim's browser. Depending on which input field you inserted the script, the script may also run everytime you load the Responsive Cookie Consent plugin page.
	
\end{enumerate}

 As described in Section 4.1, in order to test this vulnerability, we find a link to the affected plugin code, and launch a container with a clean installation of WordPress 5.2 with the plugin downloaded. After this, we activate the plugin and proceed to reproduce the proof of concept as described in the Exploit Database entry, inserting the string '">script>alert('XSS')</script>' in the rcc\_settings[border-size] input field, resulting in the following HTML displayed on the page, as well as an alert box popping up in the page:

\begin{lstlisting}
<input id="rcc_settings[border-size]" 
name="rcc-settings[border-size]" 
type="text" value=<@\textcolor{red}{""><script>alert('XSS')</script>}@>
<label class="description"
for="rcc_settings[border-size]">
\end{lstlisting}

In this case, it is clear that the \textbf{input} element is the injection starting point, and we use the \textbf{label} element as the end point, since it is the immediate element after the \textbf{input}. With this information, we are now ready to start writing the corresponding signature, as shown in Listing \ref{lst:xsnare_signature}.

\iffalse
 \lstset{basicstyle=\small}
\begin{lstlisting}
url: 'wp-admin/options-general.php?page=rcc-settings',
software: 'WordPress',
softwareDetails: 'responsive-cookie-consent',
version: '1.7',
type: 'string',
typeDet: 'single-unique',
endPoints: 
['<input id="rcc_settings[border-size]" 
name="rcc_settings[border-size]" type="text"',
'<label class="description" 
for="rcc_settings[border-size]">']
\end{lstlisting}
\fi

The URL is acquired by noting that this exploit occurs on the plugin's settings page, which is in a specific subdomain of the web site. Of course, the software running is WordPress in this case. The settings page's HTML includes a link to a stylesheet with href "http://localhost:8080/wp-content/plugins/responsive-cookie-consent/includes/css/options-page.css?ver=5.2.2", in particular, "wp-content/plugins/plugin-name" is the standard way of identifying that a WordPress page is running a certain plugin. In this case, "responsive-cookie-consent". While the entry only lists versions 1.7, 1.6, and 1.5 as vulnerable, we apply the signature for all versions less than or equal to 1.7.
Since, the exploit only occurs in this specific spot in the HTML, the typeDet is listed as "single-unique". Finally, we list the endPoints as taken from the HTML.

Finally, we load up our extension and reload the web page. In this example, we expect to not have an alert box pop up, and we manually look at the HTML to verify correct sanitization. Note that there's nothing else in between the input and label elements now:

\begin{lstlisting}
<input value="" type="text" 
name="rcc_settings[border-size]" 
id="rcc_settings[border-size]">
<label class="description"
for="rcc_settings[border-size]">
\end{lstlisting}

\fi
