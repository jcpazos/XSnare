\section{Writing Signatures}

As previously stated, we envision the process of signature development to be part of the vulnerability discovery work flow and CVE creation. As such, we expect a signature developer to have a solid understanding of the principles behind XSS so that they can properly identify the minimal section of the DOM which acts as an injection point. Similarly, it is important that they can identify unique traits of elements (e.g. HTML id's, classes, etc.) and the page overall in order to reduce the rate of false positives. In this section, we aim to show that minor effort is required from a knowledgeable security analyst when writing a signature for our extension.

\subsection{Signature language specification} 

We first provide a general description of a signature, in particular in the context of WordPress:
\begin{itemize}
	\item
	url: If the exploit occurs in a specific URL or subdomain, this is defined as a string, e.g.
	 \url{/wp-admin/options-general.php?page=relevanssi\%2Frelevanssi.php}, otherwise null.
	\item
	software: The software framework the page is running if any, e.g. WordPress. A hand-crafted page
	might not have any identifiable software.
	\item
	softwareDetails: If running any software, this provides further information about when to load a signature. For WordPress, these are plugin names as depicted in the HTML of a page running such plugin.
	\item
	version: The version number of the software/plugin/page. This is used for versioning as described earlier.
	\item 
	type: A string describing the signature type. A value of "string" describes a basic signature. A value of 'listener' describes a signature which requires an additional listener in the background page for network requests.
	\item 
	sanitizer: A string with one of the following values: "DOMPurify", "escape", and "regex". This item is optional, the default is DOMPurify.
	\item
	config: The config parameters to go along with the chosen sanitizer, if necessary. For "DOMPurify", the accepted values are as defined by the DOMPurify API (i.e DOMPurify.sanitize(dirty, config). For "escape", an additional escaping pattern can be provided. For "regex", this should be the pattern to match with the injection point content.
	\item
	typeDet: A string with the following pattern: 'occurence-uniqueness'. As described in Section 2.4, this specifies whether there are several injection points in the HTML.
	\item
	endPoints: An array of startpoint and endpoint tuples
	\item 
	endPointsPositions: An array of integer tuples. These are optional but useful when the one of the endPoints HTML are used throughout the whole page and appear a fixed number of times. For example: if an injection ending point happens on an element <h3 class='my-header'>, this element might have 10 appearances throughout the page. However, only the 4th is an injection ending point. The signature would specify the second element of the tuple to be 7, as it would be the 7th such item in a regex match array (using 1-based indexing), counting from the bottom up. For ending points, we have to count from the bottom up because the attacker can inject arbitrarily many of these elements before it, and vice versa for starting points.
\end{itemize}

Additionally, if the value of type is 'listener', the signature will have an additional field called listenerData. Similarly, to a regular signature, this consists of the following pieces of information:
\begin{itemize}
	\item 
	listenerType: The type of network listener as defined by the WebRequest API (e.g. 'script, 'XHR', etc.)
	\item
	listenerMethod: The request's HTTP method, for example "GET" or "POST".
	\item
	url: the URL of the request target.
\end{itemize}

\subsection{Signature writing process}
We now describe the process by which a signature is written after a vulnerability has been discovered:
\begin{enumerate}
	\item{
The signature developer crafts a proof of concept exploit for the given CVE. This step is not necessary but it will often help the developer correctly identify the affected areas of the DOM. For our own signatures, we heavily relied on this part because we often did not have the same information as the CVE writer.
Conversely, a knowledgeable analyst will often be able to identify the vulnerable points in the application from the server-side code.}
\item
Using information about where in the HTML the exploit will manifest itself, the developer identifies the start and end points of an injection, and creates regexes to match these. This step is particularly important because this is where the signature might end up covering a bigger part of the DOM than is required, potentially disabling desired functionality, to the detriment of the site user's experience. In particular, when multiple injection points occur in the same page, the developer might find it best to completely stop the page from loading if they think the sanitization would affect the user experience too greatly. While one of our main goals is to maintain the page's usability, there are cases where a large portion of the document would be affected by the sanitization, and we believe compromising usability for security is preferable in this case.

Furthermore, it is at this point where the developer identifies whether the exploit comes in from an external source (such as a response to an Ajax request or an external script) or is embedded in the document's mainframe HTML. This will result in a different signature layout. 
\item
Signatures are loaded for specific pages, and the developer has to specify this information, either via an URL or a regex in the HTML. For example, for a WordPress plugin, the exploit might happen in localhost/plugin-name.php. However, for another exploit, the exploit might occur in a page where the plugin is loaded, which contains the string "wp-content/plugins/plugin-name" in the HTML. Additionally, if the webpage is running pre-defined software, such as WordPress, this has to be specified in the signature as well. Much of this information is already known beforehand, and so this step can be done in conjunction with Step 2.
\item
After the signature has been written, the developer should make sure it was correctly specified. This is most easily done via testing a PoC exploit and verifying the injection has been properly sanitized. For false positives, the developer should make sure that the specified endPoints are uniquely occurring in the HTML (or if not unique, their correct positions have been stated). The browser extension can be used for the purposes of debugging. Some of our most common mistakes when writing signatures were incorrect regexes for the endpoints, and not correctly identifying that the injection occurred as part of an additional network request. These two can be easily fixed by looking through the incoming HTML in the background page's filter. 
\end{enumerate}

\subsection{Case Study: CVE-2018-10309}
Going back to our example in Section 2.4, we describe the full process of writing a signature for one of the CVEs we studied. An entry in Exploit Database \cite{studyCVE} describes a persistent XSS vulnerability in the WordPress plugin Responsive Cookie Consent for versions 1.7/1.6/1.5. This particular entry (as most do) comes with a proof of concept for the exploit: 
\begin{enumerate}
\item Access WordPress control panel.
\item Navigate to the Responsive Cookie Consent plugin page.
\item Select one of the input fields. For example, "Cookie Bar Border Bottom Size".
\item Insert the script you wish to inject.
\item Save the plugin settings.
\item Injected script will run in the victim's browser. Depending on which input field you inserted the script, the script may also run everytime you load the Responsive Cookie Consent plugin page.
	
\end{enumerate}

 As described in Section 4.1, in order to test this vulnerability, we find a link to the affected plugin code, and launch a container a clean installation of WordPress 5.2 with the plugin downloaded. After this, we activate the plugin and proceed to reproduce the proof of concept as described in the Exploit Database entry, inserting the string '">script>alert('XSS')</script>' in the rcc\_settings[border-size] input field, resulting in the following HTML displayed on the page, as well as an alert box popping up in the page:

\begin{lstlisting}
<input id="rcc_settings[border-size]" 
name="rcc-settings[border-size]" 
type="text" value=<@\textcolor{red}{""><script>alert('XSS')</script>}@>
<label class="description"
for="rcc_settings[border-size]">
\end{lstlisting}

In this case, it is clear that the input element is the injection starting point, and we use the label element as the end point, since it is the immediate element after the input. With this information, we are now ready to start writing the corresponding signature:

 \lstset{basicstyle=\small}
\begin{lstlisting}
url: 'wp-admin/options-general.php?page=rcc-settings',
software: 'WordPress',
softwareDetails: 'responsive-cookie-consent',
version: '1.7',
type: 'string',
typeDet: 'single-unique',
endPoints: 
['<input id="rcc_settings[border-size]" 
name="rcc_settings[border-size]" type="text"',
'<label class="description" 
for="rcc_settings[border-size]">']
\end{lstlisting}

The URL is acquired by noting that this exploit occurs on the plugin's settings page, which is in a specific subdomain of the web site. Of course, the software running is WordPress in this case. The settings page's HTML includes a link to a stylesheet with href "http://localhost:8080/wp-content/plugins/responsive-cookie-consent/includes/css/options-page.css?ver=5.2.2", in particular, "wp-content/plugins/plugin-name" is the standard way of identifying that a WordPress page is running a certain plugin. In this case, "responsive-cookie-consent". While the entry only lists versions 1.7, 1.6, and 1.5 as vulnerable, we apply the signature for all versions less than or equal to 1.7.
Since, the exploit only occurs in this specific spot in the HTML, the typeDet is listed as "single-unique". Finally, we list the endPoints as taken from the HTML.

Finally, we load up our extension and reload the web page. In this example, we expect to not have an alert box pop up, and we manually look at the HTML to verify correct sanitization. Note that there's nothing else in between the input and label elements now:

\begin{lstlisting}
<input value="" type="text" 
name="rcc_settings[border-size]" 
id="rcc_settings[border-size]">
<label class="description"
for="rcc_settings[border-size]">
\end{lstlisting}


